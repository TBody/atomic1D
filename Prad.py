# Program name: atomic1D/Prad.py
# Author: Thomas Body
# Author email: tajb500@york.ac.uk
# Date of creation: 15 July 2017
# 
# Program function: output the radiated power (Prad) and electron cooling power (Pcool)
#                   by using OpenADAS rates on output JSON from SD1D run
# 
# Under active development: <<TODO>> indicates development goal

def process_command_line_arguments():
	# Processes the command line arguments supplied to Prad.py, to set paths to input_file and JSON_database_path
	# 
	# input: none (all supplied via command line)
	# return:   input_file -> JSON file from SD1D run
	#           JSON_database_path -> 
	import sys, os

	# Set defaults
	input_file = '' #Path to output JSON file from SD1D
	JSON_database_path = 'json_database' #Path to json_database, which must have a subdirectory json_data with JSON files from OpenADAS
	element = '' #Impurity species being studied

	# Check command line arguments
	for command_line_argument in sys.argv:
		if 'Prad.py' == command_line_argument:
			# First argument will always be the function-name - skip this
			continue
		elif '-help' == command_line_argument:
			print('Function Prad.py called with -help')
			print('Function: calculate the radiated power along a field line')
			print('Inputs: -i=input_file')
			print('        -> path to a JSON file generated by data_dict_export.py')
			print('           operating in a SD1D I/O folder (i.e. case-##)')
			print('        -z=impurity element')
			print('        -> impurity species for which to calculate the radiative loss')
			print('        -jpath=JSON_database_path')
			print('        -> path to a folder which contains a subdirectory json_data.')
			print('           json_data should contain JSON files corresponding to OpenADAS')
			print('           .dat files. Generated by running make json_update on the')
			print('           makefile of TBody/atomic1D')
			quit()
		elif '-i' == command_line_argument[0:2]:
			# -i indicates input file 
			input_file = command_line_argument[3:]
		elif '-z' == command_line_argument[0:2]:
			# -element indicates specification of impurity element
			# Current supported are 'C'/'Carbon' and 'N'/'Nitrogen'
			element = command_line_argument[3:]
		elif '-jpath' == command_line_argument[0:6]:
			# -jpath indicates path to JSON database
			JSON_database_path = command_line_argument[7:]
		else:
			raise RuntimeError('Command ({}) not recognised'.format(command_line_argument))

	if input_file == '':
		input_file = input('Path to SD1D-output JSON file: ')

	if element == '':
		element = input('Impurity element: ')

	if os.path.isfile(input_file):
		print("Input file: {}".format(input_file))
	else:
		raise FileNotFoundError("Input file ({}) not found".format(input_file))

	if os.path.isdir(JSON_database_path):
		if os.path.isdir(JSON_database_path+'/json_data'):
			print("OpenADAS JSON database: {}".format(JSON_database_path))
		else:
			raise RuntimeError("Subdirectory json_data not found in JSON database. Might need to run make json_update on atomic1D")
	else:
		raise FileNotFoundError("OpenADAS JSON database ({}) not found".format(JSON_database_path))

	e = element.lower()
	# <<TODO>> Move this data specification to somewhere more easily found
	if e in ['c', 'carbon']:
		element = 'c'
		year = 96
		has_cx_power = True
		element_fullname = 'Carbon'
	elif e in ['n', 'nitrogen']:
		element = 'n'
		year = 96
		has_cx_power = False
		element_fullname = 'Nitrogen'
	else:
		raise NotImplementedError("Impurity element ({}) not yet implemented".format(element))
	print('Element: {}, year: {}, has cx power: {}'.format(element_fullname,year,has_cx_power))

	return [input_file, JSON_database_path, element, year, has_cx_power]

def retrive_from_JSON(file_name):
	# Inputs - a JSON file corresponding to an OpenADAS .dat file or SD1D output file
	# file_name can be either relative or absolute path to JSON file
	# Must have .json extension and match keys of creation
	# Not need for the .dat -> .json conversion, but included for reference
	import json
	from warnings import warn
	from copy import deepcopy
	import numpy as np

	file_extension  = file_name.split('.')[-1] #Look at the extension only (last element of split on '.')
	if file_extension != 'json':
		raise NotImplementedError('File extension (.{}) is not .json'.format(file_extension))

	with open(file_name,'r') as fp:
		data_dict = json.load(fp)

	if  set(data_dict.keys()) != {'charge','class','element', 'help','log_coeff','log_density','log_temperature','name','number_of_charge_states'}\
	and set(data_dict.keys()) != {'help', 'Ne', 'Nn', 'Nnorm', 'P', 'Tnorm', 'numpy_ndarrays'}:
		warn('Imported JSON file {} does not have the expected set of keys - could result in an error'.format(file_name))

	# Convert jsonified numpy.ndarrays back from nested lists
	data_dict_dejsonified = deepcopy(data_dict)

	for key in data_dict['numpy_ndarrays']:
		data_dict_dejsonified[key] = np.array(data_dict_dejsonified[key])

	return data_dict_dejsonified
	
def process_input_file(input_file):
	# process a input JSON file to extract Te(s,t), ne(s,t), ne/nn (s,t)
	# n.b. s refers to the upstream distance from the strike-point
	#      t is time (will need to add normalisation factor <<TODO>> to convert to real-time)
	# 
	# input:    input_file -> JSON file from SD1D run
	# return:   Te, ne, neutral_fraction

	# input_file can be either relative or absolute path to JSON file
	
	data_dict = retrive_from_JSON(input_file)

	# Retrieve (normalised values)
	Ne = data_dict['Ne']
	Nn = data_dict['Nn']
	# P = 2*Ne*Te => Te = P/(2*Ne)
	# N.b. division between two numpy ndarrays is piecewise
	T  = data_dict['P']/(2*data_dict['Ne'])
	
	# Neutral fraction affects charge exchange
	neutral_fraction = Nn/Ne
	
	# Retrieve normalisation factors
	Nnorm = data_dict['Nnorm']
	Tnorm = data_dict['Tnorm']
	# Converts N into m^-3, T into eV

	return [Ne*Nnorm, T*Tnorm, neutral_fraction]
		  

if __name__ == '__main__':
	# Process command line arguments to set the path to the input file (from SD1D)
	# and the JSON database (from make json_update)
	[input_file, JSON_database_path, element, year, has_cx_power] = process_command_line_arguments()
	
	# Process the input_file to extract
	# 	Ne 					= electron density (in m^-3)
	# 	T					= electron/ion temperature (in eV)
	# 	neutral_fraction	= neutral density/electron density (no units)
	[Ne, T, neutral_fraction] = process_input_file(input_file)

	





















